import type { Plugin } from "vite";
import { readFile, writeFile, mkdir } from "fs/promises";
import { resolve, dirname, relative } from "path";
import { existsSync } from "fs";
import {
  ReonoASTParser,
  type RouteInfo as ASTRouteInfo,
} from "./ast-parser.js";

export interface ReonoClientOptions {
  /**
   * Path to the JSX file containing your Reono API definition
   * @example './src/api/server.tsx'
   */
  serverFile: string;

  /**
   * Directory where the generated client will be written
   * @default './src/generated'
   */
  outputDir?: string;

  /**
   * Name of the generated client
   * @default 'api'
   */
  clientName?: string;

  /**
   * Base URL for the API (can be overridden at runtime)
   * @default ''
   */
  baseUrl?: string;

  /**
   * Whether to watch the server file for changes in dev mode
   * @default true
   */
  watch?: boolean;
}

interface RouteInfo {
  method: string;
  path: string;
  params: string[];
  hasBody: boolean;
  bodyType?: string;
  responseType?: string;
}

export function reonoClient(options: ReonoClientOptions): Plugin {
  const {
    serverFile,
    outputDir = "./src/generated",
    clientName = "api",
    baseUrl = "",
    watch = true,
  } = options;

  let root: string;

  // Define the generateClient function outside the plugin object
  async function generateClient() {
    try {
      const serverFilePath = resolve(root, serverFile);
      const outputDirPath = resolve(root, outputDir);

      if (!existsSync(serverFilePath)) {
        console.warn(`[reono-client] Server file not found: ${serverFile}`);
        return;
      }

      // Analyze the JSX file
      const routes = await analyzeServerFile(serverFilePath);

      // Generate the client code
      const clientCode = generateClientCode(routes, clientName, baseUrl);

      // Ensure output directory exists
      await mkdir(outputDirPath, { recursive: true });

      // Write the client file
      const clientFilePath = resolve(outputDirPath, `${clientName}.ts`);
      await writeFile(clientFilePath, clientCode, "utf-8");

      console.log(
        `[reono-client] Generated client: ${relative(root, clientFilePath)}`
      );
    } catch (error) {
      console.error("[reono-client] Failed to generate client:", error);
    }
  }

  return {
    name: "reono-client",

    configResolved(config: any) {
      root = config.root;
    },

    async buildStart() {
      await generateClient();
    },

    configureServer(server: any) {
      if (watch) {
        const serverFilePath = resolve(root, serverFile);
        server.watcher.add(serverFilePath);

        server.watcher.on("change", (file: string) => {
          if (file === serverFilePath) {
            generateClient();
          }
        });
      }
    },
  };

  async function analyzeServerFile(filePath: string): Promise<RouteInfo[]> {
    const parser = new ReonoASTParser();
    const astRoutes = await parser.parseServerFile(filePath);

    // Convert AST routes to plugin RouteInfo format
    return astRoutes.map(
      (astRoute): RouteInfo => ({
        method: astRoute.method,
        path: astRoute.path,
        params: astRoute.params,
        hasBody: astRoute.hasBody,
        bodyType: astRoute.bodyType,
        responseType: astRoute.responseType,
      })
    );
  }

  function generateClientCode(
    routes: RouteInfo[],
    clientName: string,
    baseUrl: string
  ): string {
    // Group routes by method to generate proper interface
    const methodGroups = new Map<string, RouteInfo[]>();
    routes.forEach((route) => {
      const method = route.method.toLowerCase();
      if (!methodGroups.has(method)) {
        methodGroups.set(method, []);
      }
      methodGroups.get(method)!.push(route);
    });

    const routeMethods = Array.from(methodGroups.entries())
      .map(([method, methodRoutes]) =>
        generateMethodOverloads(method, methodRoutes)
      )
      .join("\n");

    return `// Generated by @reono/client - DO NOT EDIT
import { createClient, type ClientRequestOptions, type CreateClientOptions } from '@reono/client/runtime';

// Route type definitions stored in a record to handle special characters
${generateRouteTypesRecord(routes)}

// Union type of all valid paths
export type ValidPaths = ${routes.map((r) => `'${r.path}'`).join(" | ") || "never"};

// Path-specific parameter requirements
${generatePathParamTypes(routes)}

// Generated client interface
export interface GeneratedApiClient {
${routeMethods}
}

// Create the typed client
function createTypedClient(options: CreateClientOptions = {}): GeneratedApiClient {
  const client = createClient({ baseUrl: '${baseUrl}', ...options });
  
  return {
${Array.from(methodGroups.entries())
  .map(([method, methodRoutes]) =>
    generateMethodImplementation(method, methodRoutes)
  )
  .join(",\n")}
  };
}

// Export the client instance
export const ${clientName} = createTypedClient();

// Export the client factory for custom configuration
export { createTypedClient as create${clientName.charAt(0).toUpperCase() + clientName.slice(1)} };
`;
  }

  function generatePathParamTypes(routes: RouteInfo[]): string {
    const pathTypes = routes
      .filter((route) => route.params.length > 0)
      .map(
        (route) =>
          `  '${route.path}': { ${route.params.map((p) => `${p}: string | number`).join("; ")} }`
      )
      .join(";\n");

    return `export type PathParams<T extends ValidPaths> = T extends keyof PathParamMap 
  ? PathParamMap[T] 
  : never;

interface PathParamMap {
${pathTypes || "  // No paths with parameters"}
}`;
  }

  function generateMethodOverloads(
    method: string,
    routes: RouteInfo[]
  ): string {
    const overloads = routes.map((route) => {
      const paramType =
        route.params.length > 0
          ? `ClientRequestOptions & { params: PathParams<'${route.path}'> }`
          : "ClientRequestOptions";

      return `  ${method}<T = any>(path: '${route.path}', options${route.params.length > 0 ? "" : "?"}: ${paramType}): Promise<T>;`;
    });

    return overloads.join("\n");
  }

  function generateMethodImplementation(
    method: string,
    routes: RouteInfo[]
  ): string {
    const implementations = routes
      .map((route) => {
        return `      case '${route.path}': return client.${method}<T>(path, options);`;
      })
      .join("\n");

    return `    ${method}: <T = any>(path: string, options?: ClientRequestOptions) => {
      switch (path) {
${implementations}
        default: throw new Error(\`Invalid path for ${method.toUpperCase()}: \${path}\`);
      }
    }`;
  }

  function generateRouteTypesRecord(routes: RouteInfo[]): string {
    const routeEntries = routes
      .map((route) => {
        const paramType =
          route.params.length > 0
            ? `{ ${route.params.map((p) => `${p}: string | number`).join("; ")} }`
            : "never";

        const routeKey = `"${route.method} ${route.path}"`;
        return `  ${routeKey}: {
    params: ${paramType};
    body: ${route.hasBody ? "any" : "never"};
    response: any;
  }`;
      })
      .join(",\n");

    return `// Route information stored in a record
export interface RouteDefinitions {
${routeEntries}
}`;
  }
}
