import type { Plugin } from "vite";
import { readFile, writeFile, mkdir } from "fs/promises";
import { resolve, dirname, relative } from "path";
import { existsSync } from "fs";

export interface ReonoClientOptions {
  /**
   * Path to the JSX file containing your Reono API definition
   * @example './src/api/server.tsx'
   */
  serverFile: string;

  /**
   * Directory where the generated client will be written
   * @default './src/generated'
   */
  outputDir?: string;

  /**
   * Name of the generated client
   * @default 'api'
   */
  clientName?: string;

  /**
   * Base URL for the API (can be overridden at runtime)
   * @default ''
   */
  baseUrl?: string;

  /**
   * Whether to watch the server file for changes in dev mode
   * @default true
   */
  watch?: boolean;
}

interface RouteInfo {
  method: string;
  path: string;
  params: string[];
  hasBody: boolean;
  bodyType?: string;
  responseType?: string;
}

export function reonoClient(options: ReonoClientOptions): Plugin {
  const {
    serverFile,
    outputDir = "./src/generated",
    clientName = "api",
    baseUrl = "",
    watch = true,
  } = options;

  let root: string;

  // Define the generateClient function outside the plugin object
  async function generateClient() {
    try {
      const serverFilePath = resolve(root, serverFile);
      const outputDirPath = resolve(root, outputDir);

      if (!existsSync(serverFilePath)) {
        console.warn(`[reono-client] Server file not found: ${serverFile}`);
        return;
      }

      // Analyze the JSX file
      const routes = await analyzeServerFile(serverFilePath);

      // Generate the client code
      const clientCode = generateClientCode(routes, clientName, baseUrl);

      // Ensure output directory exists
      await mkdir(outputDirPath, { recursive: true });

      // Write the client file
      const clientFilePath = resolve(outputDirPath, `${clientName}.ts`);
      await writeFile(clientFilePath, clientCode, "utf-8");

      console.log(
        `[reono-client] Generated client: ${relative(root, clientFilePath)}`
      );
    } catch (error) {
      console.error("[reono-client] Failed to generate client:", error);
    }
  }

  return {
    name: "reono-client",

    configResolved(config: any) {
      root = config.root;
    },

    async buildStart() {
      await generateClient();
    },

    configureServer(server: any) {
      if (watch) {
        const serverFilePath = resolve(root, serverFile);
        server.watcher.add(serverFilePath);

        server.watcher.on("change", (file: string) => {
          if (file === serverFilePath) {
            generateClient();
          }
        });
      }
    },
  };

  async function analyzeServerFile(filePath: string): Promise<RouteInfo[]> {
    const content = await readFile(filePath, "utf-8");

    // This is a simplified parser - in a real implementation, we'd use
    // a proper TypeScript AST parser or babel to analyze the JSX
    const routes: RouteInfo[] = [];

    // Extract routes using regex patterns (this is a prototype approach)
    const routePatterns = [
      /<(get|post|put|patch|delete|options|head)\s+([^>]*?)>/gi,
    ];

    for (const pattern of routePatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        // Ensure we have the expected capture groups
        if (!match[1] || !match[2]) continue;

        const method = match[1].toUpperCase();
        const attributesString = match[2];

        // Extract path attribute
        const pathMatch = attributesString.match(/path=["']([^"']+)["']/);
        if (!pathMatch || !pathMatch[1]) continue;

        const path = pathMatch[1];
        const params = extractPathParams(path);

        // Check if route has validation for body
        const hasValidation = attributesString.includes("validate=");
        const hasBody =
          ["POST", "PUT", "PATCH"].includes(method) || hasValidation;

        routes.push({
          method,
          path,
          params,
          hasBody,
        });
      }
    }

    return routes;
  }

  function extractPathParams(path: string): string[] {
    const params: string[] = [];
    const paramMatches = path.matchAll(/:([A-Za-z0-9_]+)/g);

    for (const match of paramMatches) {
      if (match[1]) {
        params.push(match[1]);
      }
    }

    return params;
  }

  function generateClientCode(
    routes: RouteInfo[],
    clientName: string,
    baseUrl: string
  ): string {
    const routeTypes = routes
      .map((route) => generateRouteType(route))
      .join("\n");

    const routeMethods = routes
      .map((route) => generateRouteMethod(route))
      .join("\n");

    return `// Generated by @reono/client - DO NOT EDIT
import { createClient, type ClientRequestOptions, type CreateClientOptions } from '@reono/client/runtime';

// Route type definitions
${routeTypes}

// Union type of all valid paths
export type ValidPaths = ${routes.map((r) => `'${r.path}'`).join(" | ") || "never"};

// Path-specific parameter requirements
${generatePathParamTypes(routes)}

// Generated client interface
export interface GeneratedApiClient {
${routeMethods}
}

// Create the typed client
function createTypedClient(options: CreateClientOptions = {}): GeneratedApiClient {
  const client = createClient({ baseUrl: '${baseUrl}', ...options });
  
  return {
${routes.map((route) => generateClientMethodImplementation(route)).join(",\n")}
  };
}

// Export the client instance
export const ${clientName} = createTypedClient();

// Export the client factory for custom configuration
export { createTypedClient as create${clientName.charAt(0).toUpperCase() + clientName.slice(1)} };
`;
  }

  function generateRouteType(route: RouteInfo): string {
    const paramType =
      route.params.length > 0
        ? `{ ${route.params.map((p) => `${p}: string | number`).join("; ")} }`
        : "never";

    return `// ${route.method} ${route.path}
export type ${getRouteTypeName(route)} = {
  params: ${paramType};
  body: ${route.hasBody ? "any" : "never"};
  response: any;
};`;
  }

  function generatePathParamTypes(routes: RouteInfo[]): string {
    const pathTypes = routes
      .filter((route) => route.params.length > 0)
      .map(
        (route) =>
          `  '${route.path}': { ${route.params.map((p) => `${p}: string | number`).join("; ")} }`
      )
      .join(";\n");

    return `export type PathParams<T extends ValidPaths> = T extends keyof PathParamMap 
  ? PathParamMap[T] 
  : never;

interface PathParamMap {
${pathTypes || "  // No paths with parameters"}
}`;
  }

  function generateRouteMethod(route: RouteInfo): string {
    const methodName = route.method.toLowerCase();
    const paramType =
      route.params.length > 0
        ? `ClientRequestOptions & { params: PathParams<'${route.path}'> }`
        : "ClientRequestOptions";

    return `  ${methodName}<T = any>(path: '${route.path}', options${route.params.length > 0 ? "" : "?"}: ${paramType}): Promise<T>;`;
  }

  function generateClientMethodImplementation(route: RouteInfo): string {
    const methodName = route.method.toLowerCase();
    const clientMethod = [
      "get",
      "post",
      "put",
      "patch",
      "delete",
      "options",
      "head",
    ].includes(methodName)
      ? methodName
      : "request";

    const args =
      clientMethod === "request"
        ? `'${route.method}', path, options`
        : "path, options";

    return `    ${methodName}: <T = any>(path: '${route.path}', options?: ClientRequestOptions) => 
      client.${clientMethod}<T>(${args})`;
  }

  function getRouteTypeName(route: RouteInfo): string {
    const pathPart = route.path
      .replace(/[/:]/g, "_")
      .replace(/_+/g, "_")
      .replace(/^_|_$/g, "");
    return `${route.method}_${pathPart}_Route`;
  }
}
